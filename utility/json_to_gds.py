#!/usr/bin/env python3

import json
import os
import sys
import logging
import re

error_context = ""

def get_set_count(card_data : dict) -> int:
    res = 0
    if 'allsets' in card_data:
        res += len(card_data['allsets'])
    if 'jpsets' in card_data:
        res += len(card_data['jpsets'])
    if res == 0:
        res = 1
    return res

def get_register_cards_gds_code(booster_data : dict) -> str:
    res = '# Content autogenerated. Data from digimoncardgame.fandom.com\n\n'
    res += 'static func register_cards():\n'
    res += '\n	CardDB.register_booster("{0}", "{1}")\n'.format(booster_data['shortname'], booster_data['name'])

    for card_data in booster_data['cards']:
        class_name = card_data['setnumber'].replace('-', '_')
        res += '	CardDB.add_card({0}.new())\n'.format(class_name)
        
        set_count = get_set_count(card_data)
        alt_index = 2
        while alt_index <= set_count:
            alt_letter = chr(ord('@') + alt_index)
            alt_class_name = class_name + '_' + alt_letter
            res += '	CardDB.add_card({0}.new())\n'.format(alt_class_name)
            alt_index += 1
    res += '\n'
    return res


def get_color_str(color : str) -> str:
    res = '""'
    color = color.lower()
    if color == 'red':
        res = 'ColorGroup.RED'
    elif color == 'blue':
        res = 'ColorGroup.BLUE'
    elif color == 'yellow':
        res = 'ColorGroup.YELLOW'
    elif color == 'green':
        res = 'ColorGroup.GREEN'
    elif color == 'white':
        res = 'ColorGroup.WHITE'
    elif color == 'purple':
        res = 'ColorGroup.PURPLE'
    elif color == 'black':
        res = 'ColorGroup.BLACK'
    return res


def get_rarity_str(card_data : dict) -> str:
    res = '""'
    rarity = card_data['rarity']
    if rarity == 'C':
        res = 'Rarity.C'
    elif rarity == 'U':
        res = 'Rarity.U'
    elif rarity == 'R':
        res = 'Rarity.R'
    elif rarity == 'SR':
        res = 'Rarity.SR'
    elif rarity == 'P':
        res = 'Rarity.P'
    elif rarity == 'SEC':
        res = 'Rarity.SEC'
    return res


def get_attribute_str(card_data : dict) -> str:
    res = '""'
    if not 'attribute' in card_data:
        return res
    attribute = card_data['attribute']
    if attribute == 'Data':
        res = 'Attribute.DATA'
    elif attribute == 'Vaccine':
        res = 'Attribute.VACCINE'
    elif attribute == 'Virus':
        res = 'Attribute.VIRUS'
    elif attribute == 'Unknown':
        res = 'Attribute.UNKNOWN'
    elif attribute == 'Free':
        res = 'Attribute.FREE'
    elif attribute == 'Variable':
        res = 'Attribute.VARIABLE'
    return res


def get_stage_level_str(card_data : dict) -> str:
    res = '""'
    stage = card_data['level']
    if 'form' in card_data:
        res = 'Stage.HYBRID'
    elif stage == '2':
        res = 'Stage.IN_TRAINING'
    elif stage == '3':
        res = 'Stage.ROOKIE'
    elif stage == '4':
        res = 'Stage.CHAMPION'
    elif stage == '5':
        res = 'Stage.ULTIMATE'
    elif stage == '6':
        res = 'Stage.MEGA'
    elif stage == '7':
        res = 'Stage.MEGA'
    else:
        print(card_data['setnumber'], "Card without stage detected!")
    return res


def get_card_type_str(card_data : dict) -> str:
    res = 'Type.DIGIMON'
    card_type = card_data['cardtype']
    if card_type == 'Tamer':
        res = 'Type.TAMER'
    elif card_type == 'Option':
        res = 'Type.OPTION'
    elif card_type == 'Digi-Egg':
        res = 'Type.DIGITAMA'
    return res


regex_replaces = {
    'DNADigivolve': lambda x: r'<DNA Digivolve: [\3] + [\4]: [\2]>',
    'DigivolveFrom': lambda x: r'Digivolve from [\3] for [\2] cost',
    'ArmorPurge': lambda x: r'[Armor Release]',
    'DigivolveName': lambda x: r'Digivolve from [\3] for [\2] cost',
    'StartYourMain': lambda x: r'[Start of Your Main Phase]',
    'ToCard': lambda x: r'[\3]',
    'Archetype': lambda x: r'[\2]',
    'Advance': lambda x: r'[Advance]',
    'Block': lambda x: r'[Blocker]',
    'Decoy': lambda x: r'[Decoy]',
    'Pierce': lambda x: r'[Piercing]',
    'EffectLink': lambda x: r'[\2]',
    'EffectLinkForm': lambda x: r'[\2]',
    'EffectLinkTrait': lambda x: r'[\2]',
    'EffectLinkTraits': lambda x: r'[\2]', # TODO
    'EffectLinkName': lambda x: r'[\2]',
    'EffectLinkAttribute': lambda x: r'[\2]',
    'EffectLinkForms': lambda x: r'[\2]',
    'EffectLinkType': lambda x: r'[\2]',
    'EffectLinkTypes': lambda x: r', '.join([i for i in x.groups() if i is not None][1:]),
    'EffectLinkNames': lambda x: r', '.join([i for i in x.groups() if i is not None][1:]),
    'SecurityAttackPlus': lambda x: r'[Security Attack +\2]' if x.group(2) else r'[Security Attack +1]',
    'SecurityAttackMinus': lambda x: r'[Security Attack -\2]' if x.group(2) else r'[Security Attack -1]',
    'Once': lambda x: r'[Twice Per Turn]' if x.group(2) == '2' else r'[Once Per Turn]',
    'Jamming': lambda x: r'[Jamming]',
    'MainTiming': lambda x: r'[Main]',
    'OnPlay': lambda x: r'[On Play]',
    'Security': lambda x: r'[Security]',
    'Retaliation': lambda x: r'[Retaliation]',
    'WhenAttacking': lambda x: r'[When Attacking]',
    'WhenDigivolve': lambda x: r'[When Digivolved]',
    'Draw': lambda x: r'[Draw \2]',
    'OnDelete': lambda x: r'[On Deletion]',
    'YourTurn': lambda x: r'[Your Turn]',
    'AllTurns': lambda x: r'[All Turns]',
    'Digiburst': lambda x: r'[Digiburst \2]' if x.group(2) and x.group(2) != '|nocategory' and x.group(2) != '|support' else r'[Digiburst]',
    'DigiburstUpto': lambda x: r'[DigiburstUpto \2]',
    'DeDigivolve': lambda x: r'[De-Digivolve \2]' if x.group(2) and not x.group(3) == 'nocategory' else r'[De-Digivolve]',
    'Digisorption': lambda x: r'[Digisorption -\2]' if x.group(2) and x.group(2) != '|nocategory' and x.group(2) != '|support' else r'[Digisorption]',
    'Recover': lambda x: r'[Recovery +\2]' if x.group(2) else r'[Recovery +1]',
    'OppTurn': lambda x: r'[Opponent Turn]',
    'Reboot': lambda x: r'[Reboot]',
    'Delay': lambda x: r'[Delay]',
    'Rush': lambda x: r'[Rush]',
    'Blitz': lambda x: r'[Blitz]',
    'EndOfAttack': lambda x: r'[End of Attack]',
    'StartYourTurn': lambda x: r'[Start of Your Turn]',
    'DiaboromonToken': lambda x: r'[Diaboromon] Token',
    'EndOppTurn': lambda x: r"[End of Opponent's Turn]",
    'EndYourTurn': lambda x: r"[End of Your Turn]",
    'EndAllTurn': lambda x: r"[End of All Turns]",
}

def normalize_card_terms(string):
    pattern = re.compile(r"{{(.+?)(?:\|(.+?))?(?:\|(.+?))?(?:\|(.+?))?}}")
    return pattern.sub(lambda x: [print("-------", x.groups()), x.expand(regex_replaces[x.group(1)](x))][1], string)


def get_card_gds_code(card_data : dict) -> str:
    global error_context
    error_context = card_data['setnumber']

    is_tama = bool(card_data['cardtype'] == 'Digi-Egg')
    is_digimon = bool(card_data['cardtype'] == 'Digimon')
    is_tamer = bool(card_data['cardtype'] == 'Tamer')
    is_option = bool(card_data['cardtype'] == 'Option')

    template = ''
    template += 'class {0} extends Card:\n'
    template += '	func _init():\n'

    template += '		name = "{0}"\n'.format(card_data['name'])
    template += '		type = {0}\n'.format(get_card_type_str(card_data))
    template += '		color = {0}\n'.format(get_color_str(card_data['colour']))
    template += '		rarity = {0}\n'.format(get_rarity_str(card_data))
    template += '		id = "{1}"\n'

    if not is_tama:
        template += '		play_cost = {0}\n'.format(card_data['playcost'])
        
    if is_digimon or is_tama:
        if 'level' in card_data and not card_data['level'] == "-":
            template += '		level = {0}\n'.format(card_data['level'])
            template += '		stage_level = {0}\n'.format(get_stage_level_str(card_data))
        else:
            template += '		level = 0\n'
            template += '		stage_level = ""\n'
    if is_digimon:
        template += '		attribute = {0}\n'.format(get_attribute_str(card_data))
    if is_digimon and 'evocost' in card_data:
        template += '		digivolve_color = {0}\n'.format(get_color_str(card_data['evocol']))
        template += '		digivolve_cost = {0}\n'.format(card_data['evocost'])
        template += '		digivolve_level = {0}\n'.format(card_data['evolvl'])
    if is_digimon and 'evocost2' in card_data and card_data['evocost2'] != '-':
        template += '		digivolve_color_2 = {0}\n'.format(get_color_str(card_data['evocol2']))
        template += '		digivolve_cost_2 = {0}\n'.format(card_data['evocost2'])
        template += '		digivolve_level_2 = {0}\n'.format(card_data['evolvl2'])
    if is_digimon or is_tama:
        template += '		digimon_type = "{0}"\n'.format(card_data['type'])
    if is_digimon:
        template += '		power = {0}\n'.format(card_data['dp'])
    if 'effect' in card_data:
        template += '		effect_text = "{0}"\n'.format(normalize_card_terms(card_data['effect']))
    if 'inheriteff' in card_data:
        if is_digimon or is_tama:
            template += '		inherited_effect_text = "{0}"\n'.format(normalize_card_terms(card_data['inheriteff']))
        else:
            template += '		sec_effect_text = "{0}"\n'.format(normalize_card_terms(card_data['inheriteff']))
    
    if 'ruling' in card_data:
        ruling_str = '		ruling = [\n'
        for r in card_data['ruling']:
            ruling_str += '					"' + r + '",\n'
        ruling_str += ']\n'
        ruling_str = normalize_card_terms(ruling_str)
        template += ruling_str
    
    card_id = card_data['setnumber'] # BT1-005
    class_name = card_id.replace('-', '_') # BT1_005
    res = template.format(class_name, card_id)
    if 'tsname' in card_data:
            res += '		notes = "{0}"\n'.format(card_data['tsname'])
    res += '\n'

    set_count = get_set_count(card_data)
    alt_index = 2
    while alt_index <= set_count:
        alt_letter = chr(ord('@') + alt_index)
        alt_id = card_id + ' (' + alt_letter + ')' # BT1-005 (B)
        alt_class_name = class_name + '_' + alt_letter # BT1_005_B
        res += template.format(alt_class_name, alt_id)
        res += '		is_parallel = true\n'
        res += '		notes = "parallel promo'
        if 'tsname' in card_data:
            res += ' ' + card_data['tsname'] + '"'
        else:
            res += '"'
        res += '\n\n'
        alt_index += 1
    
    return res


def dict_to_gds(data : dict) -> str:
    res = ''
    res += get_register_cards_gds_code(data)
    for card_data in data['cards']:
        res += get_card_gds_code(card_data)
    return res


def main():
    if len(sys.argv) < 2:
        print("Error: you have to provide one or more files as argument.")
        sys.exit(1)
    
    if sys.argv[1] == "--all":
        files = [f for f in os.listdir('.') if os.path.isfile(f) and f.endswith('.json')]
    else:
        files = sys.argv[1:]

    for filename in files:
        try:
            with open(filename, 'r') as f:
                data = json.load(f)
                gds_code = dict_to_gds(data)
                # TODO error handling
                file = open(data['shortname'] + ".gd", "w")
                file.write(gds_code) 
                file.close() 
        except Exception as e:
            logging.exception("File " + filename + " could not be open: " + error_context)
            sys.exit(1)


if __name__ == "__main__":
    main()
